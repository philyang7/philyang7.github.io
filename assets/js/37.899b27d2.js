(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{547:function(a,e,t){"use strict";t.r(e);var s={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},v=t(2),i=Object(v.a)(s,function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.slotKey}},[t("h1",{attrs:{id:"java基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java基础","aria-hidden":"true"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),t("p",[a._v("这里记录一些容易忘记或混淆的java基础知识。")]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"散列-hashcode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#散列-hashcode","aria-hidden":"true"}},[a._v("#")]),a._v(" 散列 HashCode")]),a._v(" "),t("p",[a._v("线性查询是最慢的查询方式，所以，将键值按照一定的顺序排序，并且使用二分查找能够有效的提升速度。散列将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。所以数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码，配合equals来确定键值。查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下标取到的对应部分的list，然后通过equals就可以快速找到键值。")]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"_8种基本数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8种基本数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 8种基本数据类型")]),a._v(" "),t("ul",[t("li",[a._v("浮点型（有符号类型）：float(4 byte), double(8 byte)")]),a._v(" "),t("li",[a._v("整型（有符号类型）：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)")]),a._v(" "),t("li",[a._v("字符型（无符号类型）: char(2 byte)，取值范围为0~2^16-1")]),a._v(" "),t("li",[a._v('布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值"true"和"false")')])]),a._v(" "),t("p",[a._v("对于这8种基本数据类型的变量，变量直接存储的是“值”，因此在用关系操作符==来进行比较时，比较的就是 “值” 本身。")]),a._v(" "),t("ol",[t("li",[a._v("对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；\n如果作用于引用类型的变量，则比较的是所指向的对象的地址")]),a._v(" "),t("li",[a._v("对于equals方法，注意：equals方法不能作用于基本数据类型的变量\n如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；\n诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。")])]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"map、list、set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map、list、set","aria-hidden":"true"}},[a._v("#")]),a._v(" Map、List、Set")]),a._v(" "),t("blockquote",[t("p",[a._v("Map")])]),a._v(" "),t("ol",[t("li",[a._v("Map是一种保存key-value形式对象的集合，实现类：HashMap，HashTable，TreeMap，LinkedHashMap")]),a._v(" "),t("li",[a._v("HashMap：Java 1.2引进的Hashtable的升级版，线程不安全，允许一个 null 键和多个 null 值")]),a._v(" "),t("li",[a._v("Hashtable：线程安全的，不允许 null 键和 null 值")]),a._v(" "),t("li",[a._v("LinkedHashMap：类似于HashMap，但是在迭代访问时更快，因为它使用链表维护内部次序，取得“键值对”的顺序是其插入次序")]),a._v(" "),t("li",[a._v("TreeMap：基于红黑树数据结构的实现，可以自定义排序")])]),a._v(" "),t("blockquote",[t("p",[a._v("List")])]),a._v(" "),t("ol",[t("li",[a._v("List继承自Collection接口，实现类：LinkedList，ArrayList，Vector")]),a._v(" "),t("li",[a._v("元素有放入顺序，元素可重复。")]),a._v(" "),t("li",[a._v("ArrayList：由数组实现的List，允许对元素进行快速随机访问，但是向List中间插入与删除元素的速度很慢。ListIterator只应该用来由后向前遍历 ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。")]),a._v(" "),t("li",[a._v("LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。还具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法使得LinkedList可以当作堆栈、队列和双向队列使用。")]),a._v(" "),t("li",[a._v("Vector：非常类似ArrayList，但是Vector是同步的")])]),a._v(" "),t("blockquote",[t("p",[a._v("Set")])]),a._v(" "),t("ol",[t("li",[a._v("Set继承自Collection接口，实现类：HashSet(底层由HashMap实现)，LinkedHashSet，TreeSet")]),a._v(" "),t("li",[a._v("元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的） 。")]),a._v(" "),t("li",[a._v("HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。")]),a._v(" "),t("li",[a._v("TreeSet： 保存有次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。")]),a._v(" "),t("li",[a._v("LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。")])]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"hashmap里的hashcode方法和equal方法重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap里的hashcode方法和equal方法重写","aria-hidden":"true"}},[a._v("#")]),a._v(" HashMap里的hashcode方法和equal方法重写")]),a._v(" "),t("p",[t("em",[t("strong",[a._v("使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。")])])]),a._v(" "),t("p",[a._v("HashMap中的比较key是先求出key的hashcode()，比较其值是否相等，若相等再比较equals()，若相等则认为他们是相等的。因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，则即便有相同含义的两个对象，比较也是不相等的。")]),a._v(" "),t("p",[a._v("例如，生成了两个“羊”对象，正常理解这两个对象应该是相等的，但如果你不重写 hashcode（）方法的话，比较是不相等的！HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素是否相等。")]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"红黑树（红黑二叉树）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#红黑树（红黑二叉树）","aria-hidden":"true"}},[a._v("#")]),a._v(" 红黑树（红黑二叉树）")]),a._v(" "),t("p",[a._v("TreeSet是依靠TreeMap实现的，TreeMap的实现是红黑树（红黑二叉树）算法的实现。规则：")]),a._v(" "),t("ol",[t("li",[a._v("值大于节点往右找，反之亦然")]),a._v(" "),t("li",[a._v("每个节点都只能是红色或者黑色")]),a._v(" "),t("li",[a._v("根节点是黑色")]),a._v(" "),t("li",[a._v("每个叶节点（NIL节点，空节点）是黑色的。")]),a._v(" "),t("li",[a._v("如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。")]),a._v(" "),t("li",[a._v("从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/java/1.png",alt:"avatar"}})])])},[],!1,null,null,null);i.options.__file="java-basic.md";e.default=i.exports}}]);