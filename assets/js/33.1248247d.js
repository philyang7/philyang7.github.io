(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{541:function(v,a,_){"use strict";_.r(a);var t={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},r=_(2),i=Object(r.a)(t,function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.slotKey}},[_("h1",{attrs:{id:"jvm虚拟机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm虚拟机","aria-hidden":"true"}},[v._v("#")]),v._v(" JVM虚拟机")]),v._v(" "),_("h3",{attrs:{id:"jvm内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存模型","aria-hidden":"true"}},[v._v("#")]),v._v(" JVM内存模型")]),v._v(" "),_("p",[_("img",{attrs:{src:"/img/java-guide/jvm/jvm.jpg",alt:"avatar"}})]),v._v(" "),_("ul",[_("li",[v._v("程序计数器：较小的内存空间，当前线程执行字节码的行数指示器，各线程之间独立存储。")]),v._v(" "),_("li",[v._v("Java栈：线程私有，每个方法在执行时会创建一个栈帧，用来存储局部变量表，动态链接，方法出口等信息，方法的执行就是栈帧出入栈的过程。")]),v._v(" "),_("li",[v._v("本地方法栈：保存的是Native方法的信息，当线程调用native方法后，JVM不会在虚拟机栈中创建栈帧，而是简单的动态链接并调用native方法。")]),v._v(" "),_("li",[v._v("方法区/永久区：用于存储被虚拟机加载的类信息，常量，静态变量等数据。")]),v._v(" "),_("li",[v._v("运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。")]),v._v(" "),_("li",[v._v("Java堆：用于存放new创建的对象和数组等数据。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理，所以是开发者需要重点关注的区域。")])]),v._v(" "),_("blockquote",[_("p",[v._v("线程独享还是共享："),_("br"),v._v("\n栈内存属于单个线程，每个线程都会有一个栈内存，存储的变量只能在自己所属线程中可见，即栈内存可以理解成线程的私有内存。"),_("br"),v._v("\n堆内存中对象可以被所有线程访问。")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"堆内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存","aria-hidden":"true"}},[v._v("#")]),v._v(" 堆内存")]),v._v(" "),_("p",[_("img",{attrs:{src:"/img/java-guide/jvm/heap.jpg",alt:"avatar"}})]),v._v(" "),_("ol",[_("li",[v._v("JVM内存划分为堆内存和非堆内存，堆内存分为年轻代、老年代，非堆内存就一个永久代。")]),v._v(" "),_("li",[v._v("年轻代又分为生成区Eden区和幸存区Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。")]),v._v(" "),_("li",[v._v("堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。")]),v._v(" "),_("li",[v._v("非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。")])]),v._v(" "),_("blockquote",[_("p",[v._v("在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代类似，都是方法区的实现，他们最大区别\n是：元空间并不在JVM中，而是使用本地内存。")]),v._v(" "),_("p",[v._v("移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。元空间与堆的垃圾回收进行了隔离，避免Full GC和OOM等问题。")])]),v._v(" "),_("h4",{attrs:{id:"分代概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分代概念","aria-hidden":"true"}},[v._v("#")]),v._v(" 分代概念")]),v._v(" "),_("p",[v._v("新生成的对象首先放到年轻代Eden生成区，当Eden空间满了，触发Minor GC。"),_("br"),v._v("\n存活下来的对象移动到S0区，S0区满后触发执行Minor GC，S0区存活对象移动到S1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"垃圾回收算法（gc）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法（gc）","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾回收算法（GC）")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("标记-清除（Mark-Sweep）")]),v._v(" "),_("p",[_("img",{attrs:{src:"/img/java-guide/jvm/1.jpg",alt:"avatar"}})]),v._v(" "),_("p",[v._v("首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。")])]),v._v(" "),_("li",[_("p",[v._v("复制（Copy）")]),v._v(" "),_("p",[_("img",{attrs:{src:"/img/java-guide/jvm/2.jpg",alt:"avatar"}})]),v._v(" "),_("p",[v._v("将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。")])]),v._v(" "),_("li",[_("p",[v._v("标记-整理（Mark-Compact）")]),v._v(" "),_("p",[_("img",{attrs:{src:"/img/java-guide/jvm/3.jpg",alt:"avatar"}})]),v._v(" "),_("p",[v._v("首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。")])])]),v._v(" "),_("blockquote",[_("p",[v._v("一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。"),_("br"),v._v("\n而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("串行收集器（Serial）")]),v._v(" "),_("p",[v._v("比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。")])]),v._v(" "),_("li",[_("p",[v._v("并行收集器（Parallel）")]),v._v(" "),_("p",[v._v("多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。")])]),v._v(" "),_("li",[_("p",[v._v("CMS收集器（Concurrent Mark Sweep）")]),v._v(" "),_("p",[v._v("CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：")]),v._v(" "),_("ul",[_("li",[v._v("初始标记（Initial Mark）")]),v._v(" "),_("li",[v._v("并发标记（Concurrent Mark）")]),v._v(" "),_("li",[v._v("重新标记（Remark）")]),v._v(" "),_("li",[v._v("并发清除（Concurrent Sweep）")])]),v._v(" "),_("p",[v._v("初始标记、重新标记这两个步骤仍然需要暂停应用线程。"),_("br")]),v._v(" "),_("p",[v._v("初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。"),_("br"),v._v("\n并发标记阶段是标记可回收对象。"),_("br"),v._v("\n重新标记阶段则是为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间短。"),_("br")]),v._v(" "),_("blockquote",[_("p",[v._v("由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，CMS收集器内存回收与用户一起并发执行的，大大减少了暂停时间。")])])]),v._v(" "),_("li",[_("p",[v._v("G1收集器（Garbage First）")]),v._v(" "),_("p",[v._v("G1收集器将堆内存划分多个大小相等的独立区域，并且能预测暂停时间，能预测原因它能避免对整个堆进行全区收集。"),_("br"),v._v("\nG1跟踪各个区域里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域，从而保证了再有限时间内获得更高的收集效率。")]),v._v(" "),_("p",[v._v("G1收集器工作工程分为4个步骤，包括：")]),v._v(" "),_("ul",[_("li",[v._v("初始标记（Initial Mark）")]),v._v(" "),_("li",[v._v("并发标记（Concurrent Mark）")]),v._v(" "),_("li",[v._v("最终标记（Final Mark）")]),v._v(" "),_("li",[v._v("筛选回收（Live Data Counting and Evacuation）")])]),v._v(" "),_("p",[v._v("初始标记与CMS一样，标记一下GC Roots能直接关联到的对象。"),_("br"),v._v("\n并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。"),_("br"),v._v("\n最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。"),_("br"),v._v("\n筛选回收阶段对各个区域回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。")])])])])},[],!1,null,null,null);i.options.__file="jvm.md";a.default=i.exports}}]);